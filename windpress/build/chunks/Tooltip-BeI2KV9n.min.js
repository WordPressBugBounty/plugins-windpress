import { $ as useForwardExpose, a0 as _sfc_main$8, c as createContext, a1 as injectTooltipProviderContext, h as useVModel, a2 as useTimeoutFn, a3 as _sfc_main$9, a4 as useEventListener, a5 as _sfc_main$a, a6 as _sfc_main$b, a7 as _sfc_main$c, T as useForwardProps, a8 as useGraceArea, r as useForwardPropsEmits, a9 as Presence, aa as _sfc_main$d, u as useId, P as Primitive, ab as _sfc_main$e, G as usePortal, H as defu, t as tv, s as useAppConfig, ac as _sfc_main$f, __tla as __tla_0 } from "../assets/dashboard-B8j97Vsq.js";
import { d as defineComponent, D as createBlock, E as openBlock, G as withCtx, H as renderSlot, _ as normalizeProps, $ as guardReactiveProps, u as unref, f as computed, j as watch, r as ref, a5 as useSlots, C as Comment, m as onMounted, N as createVNode, A as mergeProps, a2 as createTextVNode, a3 as toDisplayString, a1 as resolveDynamicComponent, a7 as toHandlers, q as toRef, O as createCommentVNode, U as createElementBlock, a4 as normalizeClass, F as Fragment, V as renderList } from "./runtime-core.esm-bundler-BkeE3T8c.min.js";
import { a as withModifiers } from "./runtime-dom.esm-bundler-Dg33AbjM.min.js";
import { r as reactivePick } from "./index-DVDdEdAO.min.js";
let _sfc_main;
let __tla = Promise.all([
  (() => {
    try {
      return __tla_0;
    } catch {
    }
  })()
]).then(async () => {
  const _sfc_main$7 = defineComponent({
    __name: "TooltipArrow",
    props: {
      width: {
        default: 10
      },
      height: {
        default: 5
      },
      asChild: {
        type: Boolean
      },
      as: {
        default: "svg"
      }
    },
    setup(__props) {
      const props = __props;
      useForwardExpose();
      return (_ctx, _cache) => {
        return openBlock(), createBlock(unref(_sfc_main$8), normalizeProps(guardReactiveProps(props)), {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "default")
          ]),
          _: 3
        }, 16);
      };
    }
  });
  const TOOLTIP_OPEN = "tooltip.open";
  const [injectTooltipRootContext, provideTooltipRootContext] = createContext("TooltipRoot");
  const _sfc_main$6 = defineComponent({
    __name: "TooltipRoot",
    props: {
      defaultOpen: {
        type: Boolean,
        default: false
      },
      open: {
        type: Boolean,
        default: void 0
      },
      delayDuration: {
        default: void 0
      },
      disableHoverableContent: {
        type: Boolean,
        default: void 0
      },
      disableClosingTrigger: {
        type: Boolean,
        default: void 0
      },
      disabled: {
        type: Boolean,
        default: void 0
      },
      ignoreNonKeyboardFocus: {
        type: Boolean,
        default: void 0
      }
    },
    emits: [
      "update:open"
    ],
    setup(__props, { emit: __emit }) {
      const props = __props;
      const emit = __emit;
      useForwardExpose();
      const providerContext = injectTooltipProviderContext();
      const disableHoverableContent = computed(() => props.disableHoverableContent ?? providerContext.disableHoverableContent.value);
      const disableClosingTrigger = computed(() => props.disableClosingTrigger ?? providerContext.disableClosingTrigger.value);
      const disableTooltip = computed(() => props.disabled ?? providerContext.disabled.value);
      const delayDuration = computed(() => props.delayDuration ?? providerContext.delayDuration.value);
      const ignoreNonKeyboardFocus = computed(() => props.ignoreNonKeyboardFocus ?? providerContext.ignoreNonKeyboardFocus.value);
      const open = useVModel(props, "open", emit, {
        defaultValue: props.defaultOpen,
        passive: props.open === void 0
      });
      watch(open, (isOpen) => {
        if (!providerContext.onClose) return;
        if (isOpen) {
          providerContext.onOpen();
          document.dispatchEvent(new CustomEvent(TOOLTIP_OPEN));
        } else {
          providerContext.onClose();
        }
      });
      const wasOpenDelayedRef = ref(false);
      const trigger = ref();
      const stateAttribute = computed(() => {
        if (!open.value) return "closed";
        return wasOpenDelayedRef.value ? "delayed-open" : "instant-open";
      });
      const { start: startTimer, stop: clearTimer } = useTimeoutFn(() => {
        wasOpenDelayedRef.value = true;
        open.value = true;
      }, delayDuration, {
        immediate: false
      });
      function handleOpen() {
        clearTimer();
        wasOpenDelayedRef.value = false;
        open.value = true;
      }
      function handleClose() {
        clearTimer();
        open.value = false;
      }
      function handleDelayedOpen() {
        startTimer();
      }
      provideTooltipRootContext({
        contentId: "",
        open,
        stateAttribute,
        trigger,
        onTriggerChange(el) {
          trigger.value = el;
        },
        onTriggerEnter() {
          if (providerContext.isOpenDelayed.value) handleDelayedOpen();
          else handleOpen();
        },
        onTriggerLeave() {
          if (disableHoverableContent.value) {
            handleClose();
          } else {
            clearTimer();
          }
        },
        onOpen: handleOpen,
        onClose: handleClose,
        disableHoverableContent,
        disableClosingTrigger,
        disabled: disableTooltip,
        ignoreNonKeyboardFocus
      });
      return (_ctx, _cache) => {
        return openBlock(), createBlock(unref(_sfc_main$9), null, {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "default", {
              open: unref(open)
            })
          ]),
          _: 3
        });
      };
    }
  });
  const _sfc_main$5 = defineComponent({
    __name: "TooltipContentImpl",
    props: {
      ariaLabel: {},
      asChild: {
        type: Boolean
      },
      as: {},
      side: {
        default: "top"
      },
      sideOffset: {
        default: 0
      },
      align: {
        default: "center"
      },
      alignOffset: {},
      avoidCollisions: {
        type: Boolean,
        default: true
      },
      collisionBoundary: {
        default: () => []
      },
      collisionPadding: {
        default: 0
      },
      arrowPadding: {
        default: 0
      },
      sticky: {
        default: "partial"
      },
      hideWhenDetached: {
        type: Boolean,
        default: false
      },
      positionStrategy: {},
      updatePositionStrategy: {}
    },
    emits: [
      "escapeKeyDown",
      "pointerDownOutside"
    ],
    setup(__props, { emit: __emit }) {
      const props = __props;
      const emits = __emit;
      const rootContext = injectTooltipRootContext();
      const { forwardRef } = useForwardExpose();
      const slot = useSlots();
      const defaultSlot = computed(() => {
        var _a;
        return (_a = slot.default) == null ? void 0 : _a.call(slot, {});
      });
      const ariaLabel = computed(() => {
        var _a;
        if (props.ariaLabel) return props.ariaLabel;
        let content = "";
        function recursiveTextSearch(node) {
          if (typeof node.children === "string" && node.type !== Comment) content += node.children;
          else if (Array.isArray(node.children)) node.children.forEach((child) => recursiveTextSearch(child));
        }
        (_a = defaultSlot.value) == null ? void 0 : _a.forEach((node) => recursiveTextSearch(node));
        return content;
      });
      const popperContentProps = computed(() => {
        const { ariaLabel: _, ...restProps } = props;
        return restProps;
      });
      onMounted(() => {
        useEventListener(window, "scroll", (event) => {
          const target = event.target;
          if (target == null ? void 0 : target.contains(rootContext.trigger.value)) rootContext.onClose();
        });
        useEventListener(window, TOOLTIP_OPEN, rootContext.onClose);
      });
      return (_ctx, _cache) => {
        return openBlock(), createBlock(unref(_sfc_main$c), {
          "as-child": "",
          "disable-outside-pointer-events": false,
          onEscapeKeyDown: _cache[0] || (_cache[0] = ($event) => emits("escapeKeyDown", $event)),
          onPointerDownOutside: _cache[1] || (_cache[1] = (event) => {
            var _a;
            if (unref(rootContext).disableClosingTrigger.value && ((_a = unref(rootContext).trigger.value) == null ? void 0 : _a.contains(event.target))) event.preventDefault();
            emits("pointerDownOutside", event);
          }),
          onFocusOutside: _cache[2] || (_cache[2] = withModifiers(() => {
          }, [
            "prevent"
          ])),
          onDismiss: _cache[3] || (_cache[3] = ($event) => unref(rootContext).onClose())
        }, {
          default: withCtx(() => [
            createVNode(unref(_sfc_main$a), mergeProps({
              ref: unref(forwardRef),
              "data-state": unref(rootContext).stateAttribute.value
            }, {
              ..._ctx.$attrs,
              ...popperContentProps.value
            }, {
              style: {
                "--reka-tooltip-content-transform-origin": "var(--reka-popper-transform-origin)",
                "--reka-tooltip-content-available-width": "var(--reka-popper-available-width)",
                "--reka-tooltip-content-available-height": "var(--reka-popper-available-height)",
                "--reka-tooltip-trigger-width": "var(--reka-popper-anchor-width)",
                "--reka-tooltip-trigger-height": "var(--reka-popper-anchor-height)"
              }
            }), {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "default"),
                createVNode(unref(_sfc_main$b), {
                  id: unref(rootContext).contentId,
                  role: "tooltip"
                }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString(ariaLabel.value), 1)
                  ]),
                  _: 1
                }, 8, [
                  "id"
                ])
              ]),
              _: 3
            }, 16, [
              "data-state"
            ])
          ]),
          _: 3
        });
      };
    }
  });
  const _sfc_main$4 = defineComponent({
    __name: "TooltipContentHoverable",
    props: {
      ariaLabel: {},
      asChild: {
        type: Boolean
      },
      as: {},
      side: {},
      sideOffset: {},
      align: {},
      alignOffset: {},
      avoidCollisions: {
        type: Boolean
      },
      collisionBoundary: {},
      collisionPadding: {},
      arrowPadding: {},
      sticky: {},
      hideWhenDetached: {
        type: Boolean
      },
      positionStrategy: {},
      updatePositionStrategy: {}
    },
    setup(__props) {
      const props = __props;
      const forwardedProps = useForwardProps(props);
      const { forwardRef, currentElement } = useForwardExpose();
      const { trigger, onClose } = injectTooltipRootContext();
      const providerContext = injectTooltipProviderContext();
      const { isPointerInTransit, onPointerExit } = useGraceArea(trigger, currentElement);
      providerContext.isPointerInTransitRef = isPointerInTransit;
      onPointerExit(() => {
        onClose();
      });
      return (_ctx, _cache) => {
        return openBlock(), createBlock(_sfc_main$5, mergeProps({
          ref: unref(forwardRef)
        }, unref(forwardedProps)), {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "default")
          ]),
          _: 3
        }, 16);
      };
    }
  });
  const _sfc_main$3 = defineComponent({
    __name: "TooltipContent",
    props: {
      forceMount: {
        type: Boolean
      },
      ariaLabel: {},
      asChild: {
        type: Boolean
      },
      as: {},
      side: {
        default: "top"
      },
      sideOffset: {},
      align: {},
      alignOffset: {},
      avoidCollisions: {
        type: Boolean
      },
      collisionBoundary: {},
      collisionPadding: {},
      arrowPadding: {},
      sticky: {},
      hideWhenDetached: {
        type: Boolean
      },
      positionStrategy: {},
      updatePositionStrategy: {}
    },
    emits: [
      "escapeKeyDown",
      "pointerDownOutside"
    ],
    setup(__props, { emit: __emit }) {
      const props = __props;
      const emits = __emit;
      const rootContext = injectTooltipRootContext();
      const forwarded = useForwardPropsEmits(props, emits);
      const { forwardRef } = useForwardExpose();
      return (_ctx, _cache) => {
        return openBlock(), createBlock(unref(Presence), {
          present: _ctx.forceMount || unref(rootContext).open.value
        }, {
          default: withCtx(() => [
            (openBlock(), createBlock(resolveDynamicComponent(unref(rootContext).disableHoverableContent.value ? _sfc_main$5 : _sfc_main$4), mergeProps({
              ref: unref(forwardRef)
            }, unref(forwarded)), {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            }, 16))
          ]),
          _: 3
        }, 8, [
          "present"
        ]);
      };
    }
  });
  const _sfc_main$2 = defineComponent({
    __name: "TooltipPortal",
    props: {
      to: {},
      disabled: {
        type: Boolean
      },
      defer: {
        type: Boolean
      },
      forceMount: {
        type: Boolean
      }
    },
    setup(__props) {
      const props = __props;
      return (_ctx, _cache) => {
        return openBlock(), createBlock(unref(_sfc_main$d), normalizeProps(guardReactiveProps(props)), {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "default")
          ]),
          _: 3
        }, 16);
      };
    }
  });
  const _sfc_main$1 = defineComponent({
    __name: "TooltipTrigger",
    props: {
      reference: {},
      asChild: {
        type: Boolean
      },
      as: {
        default: "button"
      }
    },
    setup(__props) {
      const props = __props;
      const rootContext = injectTooltipRootContext();
      const providerContext = injectTooltipProviderContext();
      rootContext.contentId || (rootContext.contentId = useId(void 0, "reka-tooltip-content"));
      const { forwardRef, currentElement: triggerElement } = useForwardExpose();
      const isPointerDown = ref(false);
      const hasPointerMoveOpened = ref(false);
      const tooltipListeners = computed(() => {
        if (rootContext.disabled.value) return {};
        return {
          click: handleClick,
          focus: handleFocus,
          pointermove: handlePointerMove,
          pointerleave: handlePointerLeave,
          pointerdown: handlePointerDown,
          blur: handleBlur
        };
      });
      onMounted(() => {
        rootContext.onTriggerChange(triggerElement.value);
      });
      function handlePointerUp() {
        setTimeout(() => {
          isPointerDown.value = false;
        }, 1);
      }
      function handlePointerDown() {
        if (rootContext.open) {
          rootContext.onClose();
        }
        isPointerDown.value = true;
        document.addEventListener("pointerup", handlePointerUp, {
          once: true
        });
      }
      function handlePointerMove(event) {
        if (event.pointerType === "touch") return;
        if (!hasPointerMoveOpened.value && !providerContext.isPointerInTransitRef.value) {
          rootContext.onTriggerEnter();
          hasPointerMoveOpened.value = true;
        }
      }
      function handlePointerLeave() {
        rootContext.onTriggerLeave();
        hasPointerMoveOpened.value = false;
      }
      function handleFocus(event) {
        var _a, _b;
        if (isPointerDown.value) return;
        if (rootContext.ignoreNonKeyboardFocus.value && !((_b = (_a = event.target).matches) == null ? void 0 : _b.call(_a, ":focus-visible"))) return;
        rootContext.onOpen();
      }
      function handleBlur() {
        rootContext.onClose();
      }
      function handleClick() {
        if (!rootContext.disableClosingTrigger.value) rootContext.onClose();
      }
      return (_ctx, _cache) => {
        return openBlock(), createBlock(unref(_sfc_main$e), {
          "as-child": "",
          reference: _ctx.reference
        }, {
          default: withCtx(() => [
            createVNode(unref(Primitive), mergeProps({
              ref: unref(forwardRef),
              "aria-describedby": unref(rootContext).open.value ? unref(rootContext).contentId : void 0,
              "data-state": unref(rootContext).stateAttribute.value,
              as: _ctx.as,
              "as-child": props.asChild,
              "data-grace-area-trigger": ""
            }, toHandlers(tooltipListeners.value)), {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            }, 16, [
              "aria-describedby",
              "data-state",
              "as",
              "as-child"
            ])
          ]),
          _: 3
        }, 8, [
          "reference"
        ]);
      };
    }
  });
  const theme = {
    "slots": {
      "content": "flex items-center gap-1 bg-default text-highlighted shadow-sm rounded-sm ring ring-default h-6 px-2 py-1 text-xs select-none data-[state=delayed-open]:animate-[scale-in_100ms_ease-out] data-[state=closed]:animate-[scale-out_100ms_ease-in] origin-(--reka-tooltip-content-transform-origin) pointer-events-auto",
      "arrow": "fill-default",
      "text": "truncate",
      "kbds": "hidden lg:inline-flex items-center shrink-0 gap-0.5 before:content-['\xB7'] before:me-0.5",
      "kbdsSize": "sm"
    }
  };
  _sfc_main = {
    __name: "Tooltip",
    props: {
      text: {
        type: String,
        required: false
      },
      kbds: {
        type: Array,
        required: false
      },
      content: {
        type: Object,
        required: false
      },
      arrow: {
        type: [
          Boolean,
          Object
        ],
        required: false
      },
      portal: {
        type: [
          Boolean,
          String
        ],
        required: false,
        skipCheck: true,
        default: true
      },
      class: {
        type: null,
        required: false
      },
      ui: {
        type: null,
        required: false
      },
      defaultOpen: {
        type: Boolean,
        required: false
      },
      open: {
        type: Boolean,
        required: false
      },
      delayDuration: {
        type: Number,
        required: false
      },
      disableHoverableContent: {
        type: Boolean,
        required: false
      },
      disableClosingTrigger: {
        type: Boolean,
        required: false
      },
      disabled: {
        type: Boolean,
        required: false
      },
      ignoreNonKeyboardFocus: {
        type: Boolean,
        required: false
      }
    },
    emits: [
      "update:open"
    ],
    setup(__props, { emit: __emit }) {
      const props = __props;
      const emits = __emit;
      const slots = useSlots();
      const appConfig = useAppConfig();
      const rootProps = useForwardPropsEmits(reactivePick(props, "defaultOpen", "open", "delayDuration", "disableHoverableContent", "disableClosingTrigger", "disabled", "ignoreNonKeyboardFocus"), emits);
      const portalProps = usePortal(toRef(() => props.portal));
      const contentProps = toRef(() => defu(props.content, {
        side: "bottom",
        sideOffset: 8,
        collisionPadding: 8
      }));
      const arrowProps = toRef(() => props.arrow);
      const ui = computed(() => {
        var _a;
        return tv({
          extend: tv(theme),
          ...((_a = appConfig.ui) == null ? void 0 : _a.tooltip) || {}
        })({
          side: contentProps.value.side
        });
      });
      return (_ctx, _cache) => {
        return openBlock(), createBlock(unref(_sfc_main$6), normalizeProps(guardReactiveProps(unref(rootProps))), {
          default: withCtx(({ open }) => [
            !!slots.default ? (openBlock(), createBlock(unref(_sfc_main$1), mergeProps({
              key: 0
            }, _ctx.$attrs, {
              "as-child": "",
              class: props.class
            }), {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "default", {
                  open
                })
              ]),
              _: 2
            }, 1040, [
              "class"
            ])) : createCommentVNode("", true),
            createVNode(unref(_sfc_main$2), normalizeProps(guardReactiveProps(unref(portalProps))), {
              default: withCtx(() => {
                var _a;
                return [
                  createVNode(unref(_sfc_main$3), mergeProps(contentProps.value, {
                    class: ui.value.content({
                      class: [
                        !slots.default && props.class,
                        (_a = props.ui) == null ? void 0 : _a.content
                      ]
                    })
                  }), {
                    default: withCtx(() => {
                      var _a2;
                      return [
                        renderSlot(_ctx.$slots, "content", {}, () => {
                          var _a3, _b, _c;
                          return [
                            __props.text ? (openBlock(), createElementBlock("span", {
                              key: 0,
                              class: normalizeClass(ui.value.text({
                                class: (_a3 = props.ui) == null ? void 0 : _a3.text
                              }))
                            }, toDisplayString(__props.text), 3)) : createCommentVNode("", true),
                            ((_b = __props.kbds) == null ? void 0 : _b.length) ? (openBlock(), createElementBlock("span", {
                              key: 1,
                              class: normalizeClass(ui.value.kbds({
                                class: (_c = props.ui) == null ? void 0 : _c.kbds
                              }))
                            }, [
                              (openBlock(true), createElementBlock(Fragment, null, renderList(__props.kbds, (kbd, index) => {
                                var _a4;
                                return openBlock(), createBlock(_sfc_main$f, mergeProps({
                                  key: index,
                                  size: ((_a4 = props.ui) == null ? void 0 : _a4.kbdsSize) || ui.value.kbdsSize(),
                                  ref_for: true
                                }, typeof kbd === "string" ? {
                                  value: kbd
                                } : kbd), null, 16, [
                                  "size"
                                ]);
                              }), 128))
                            ], 2)) : createCommentVNode("", true)
                          ];
                        }),
                        !!__props.arrow ? (openBlock(), createBlock(unref(_sfc_main$7), mergeProps({
                          key: 0
                        }, arrowProps.value, {
                          class: ui.value.arrow({
                            class: (_a2 = props.ui) == null ? void 0 : _a2.arrow
                          })
                        }), null, 16, [
                          "class"
                        ])) : createCommentVNode("", true)
                      ];
                    }),
                    _: 3
                  }, 16, [
                    "class"
                  ])
                ];
              }),
              _: 3
            }, 16)
          ]),
          _: 3
        }, 16);
      };
    }
  };
});
export {
  _sfc_main as _,
  __tla
};
